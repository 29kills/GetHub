//多态

/*
一、先介绍一下虚函数：
1、实现：在类的成员函数前加关键字virtual，则这个成员函数变为虚函数
2、虚函数的重写：在子类中定义一个与父类完全相同的虚函数（函数名相同，参数相同，返回类型相同，协变除外），则子类会覆盖掉父类中的这个虚函数，称为重写
注：1、父类必须加关键字virtual,子类可不用加virtual关键字，因为子类会继承父类的特性
    2、协变----返回类型是对应类的的指针或引用(同为指针或引用)
	3、静态成员函数不能定义的虚函数
	4、只有类的成员函数才能定义成虚函数
	5、类外定义不可加virtual关键字，类内声明时可加virtual关键字
    6、构造函数不可为虚函数，析构函数最好定义成虚函数
    原因：构造函数定义成虚函数，调用构造函数时会调用虚表，在虚表中找构造函数，但由于对象还未实例化，所以还未创建续表，导致找不到构造函数出错。

	7、析构函数定义虚函数：父类的指针有可能指向的是子类的对象，若子类的析构函数不是多态，则只调用父类的析构，而不会调用子类的析构，导致子类的空间未释放，造成内存泄漏。
	列：A * aa = new B; //父类指针指向子类的对象。
	    delete aa; //析构只调用父类的析构，导致子类内存泄露。
	若将析构函数定义成虚函数，由于父类和子类的析构函数名实际是相同的，所以会构成重写。析构时根据对象调用对应的析构函数，从而避免内存泄漏问题。

	8、内联函数不可定义成虚函数？
	内联函数是在编译时进行展开的，虚函数的调用是在运行时动态绑定的，所以不可定义成虚函数。

	9、静态成员函数不可定义成虚函数？
	静态成员函数属于类的，不属于某个对象，是所有对象的共有，所以没必要在运行时联编，没必要定义成虚函数。

	10、友元函数不可定义成虚函数？
	友元函数不可被继承，不可继承的函数不可定义成虚函数。

其它：
1、含有虚函数的类：会创建一个虚表，用于存储虚函数的地址，虚表实际主要就是一个函数指针数组。
2、子类会继承父类的虚函数，会重写所有父类中相同的虚函数，但只将自己的虚函数写在最先继承的父类的虚表中。
3、类中不存虚表，而是存指向这个虚表的的指针。虚表存在代码段中，同类的所有对象共用一个虚表。

二、纯虚函数：
1、方法：在声明时将成员函数的虚函数后写 = 0，则该成员函数即为纯虚函数。
注：写 = 0；的意思是将函数的地址初始化为0，告诉编译器不为该函数编制，从而阻止该类的实例化。

2、含有纯虚函数的类称为抽象类。抽象类不可实例化出对象，纯虚函数在派生类中重新定以后，派生类才能实例化出对象，父类还是不可实例化出对象。
目的：让子类继承并实现他的接口方法
作用：接口与实现分离，不仅把数据成员隐藏，还把实现完全隐藏，只留一些接口给外部调用。从而即使将来实现改变，接口可以保持不变，向后兼容。

这种彻底的封装思想，体现了面向对象的动态绑定技术，主要引用于COM，CORBA等体系结构。
函数都是public的纯虚函数的类称为接口类。


三、多态：

1、多态就是多种形态，C++的多态分为静态多态和动态多态
静态多态：如重载，在编译时进行决议(联编)，将函数地址放到函数调用处。
动态多态：通过继承重写基类的虚函数实现的多态，在运行时进行决议(联编）。
多态的虚函数存放在虚表中，虚表实际就是一个函数指针数组，由于数组下标只有在运行时才能确定。所以重写是动态多态。

2、作用：同一接口实现不同的功能，调用结果与对象有关。根据对象调用各自对应的方法，子对象调用子类的，父类对象调用父类的。
不是多态时，调用与类型有关。根据类调用对应的方法。

3、当使用基类的指针或引用调用重写的虚函数时，指向父类调用的就是父类的虚函数，指向子类调用的就是子类的虚函数。

必要条件：
1、调用的必须是子类重写了父类的虚函数
2、必须是父类的指针或引用。（根据所指向的类或引用的对象调用，子类对象调用子类的，父类对象调用父类的。）


继承体系中同名的函数：
一、重载：
1、在同一个作用域
2、函数名相同，参数不同
3、返回值可不同

二、重写（覆盖）
1、在不同的作用域（分别在子类和父类中）
2、函数名相同，参数相同，返回值类型相同（协变除外）
3、访问修饰符可不同
4、基类必须有virtual关键字修饰

三、重定义（隐藏）
1、不在同一作用域（分别在子类和父类中）
2、函数名相同
3、在子类和父类中，不构成重写即为重定义


/*


//菱形虚继承+虚函数

#include<iostream>
using namespace std;

class A
{
public:

	A()
	{
		cout <<"A构造"<< endl;
	}

	~A()
	{
		cout <<"B析构"<< endl;
	}
	virtual void Fun1()
	{
		cout << "A.Fun()" << endl;
	}

	void Funa()
	{
		cout << "a.Funa()" << endl;
	}
public:
	int _a;
};

class B : virtual public A
{
public:
	B()
	{
		cout <<"B构造"<< endl;
	}

	virtual void Fun2()
	{
		cout << "B.Fun()" << endl;
	}

	void Funb()
	{
		cout << " b.Funb()" << endl;
	}

	~B()
	{
		cout <<"B析构"<< endl;
	}

public:
	int _b;
};


class C : virtual public A
{
public:
	C()
	{
		cout <<"C构造"<< endl;
	}

	virtual void Fun3()
	{
		cout << "c.Fun()" << endl;
	}

	void Funb()
	{
		cout << " c.Funb()" << endl;
	}

	~C()
	{
		cout <<"C析构"<< endl;
	}

public:
	int _c;
};

class D : public B,public C
{
public:
	D()
	{
		cout <<"D构造"<< endl;
	}

	virtual void Fun()
	{
		cout << "D.Fun4()" << endl;
	}

	void Funb()
	{
		cout << " d.Funb()" << endl;
	}

	~D()
	{
		cout <<"D析构"<< endl;
	}

public:
	int _d;
};

void test5()
{
	A aa;
	B bb;
	C cc;
	D dd;
	dd._a = 1;
	dd._b = 2;
	dd._c = 3;
	dd._d = 4;

	cout << sizeof(aa) << endl; //8
	cout << sizeof(bb) << endl; //20
	cout << sizeof(cc) << endl; //20
	cout << sizeof(dd) << endl; //36 = 20+20-8+4 ，虚继承B/C占用同一个父类A，-8
}

*/



//菱形虚继承+多态

#include<iostream>
using namespace std;

class A
{
public:

	A()
	{
		cout <<"A构造"<< endl;
	}

	~A()
	{
		cout <<"B析构"<< endl;
	}

	virtual void Fun()
	{
		cout << "A.Fun()" << endl;
	}

	virtual void Fun1()
	{
		cout << "A.Fun1()" << endl;
	}


	void Funa()
	{
		cout << "a.Funa()" << endl;
	}
public:
	int _a;
};

class B : virtual public A
{
public:
	B()
	{
		cout <<"B构造"<< endl;
	}

	virtual void Fun()
	{
		cout << "B.Fun()" << endl;
	}

	virtual void Fun2()
	{
		cout << "B.Fun()" << endl;
	}

	void Funb()
	{
		cout << " B.Funb()" << endl;
	}

	~B()
	{
		cout <<"B析构"<< endl;
	}

public:
	int _b;
};


class C : virtual public A
{
public:
	C()
	{
		cout <<"C构造"<< endl;
	}

	virtual void Fun()
	{
		cout << "C.Fun()" << endl;
	}

	virtual void Fun3()
	{
		cout << "C.Fun()" << endl;
	}

	void Funb()
	{
		cout << " c.Funb()" << endl;
	}

	~C()
	{
		cout <<"C析构"<< endl;
	}

public:
	int _c;
};

class D : public B,public C
{
public:
	D()
	{
		cout <<"D构造"<< endl;
	}

	virtual void Fun()
	{
		cout << "D.Fun()" << endl;
	}

	virtual void Fun4()
	{
		cout << "D.Fun4()" << endl;
	}

	void Funb()
	{
		cout << " d.Funb()" << endl;
	}

	~D()
	{
		cout <<"D析构"<< endl;
	}

public:
	int _d;
};

void test5()
{
	A aa;
	B bb;
	C cc;
	D dd;
	dd._a = 1;
	dd._b = 2;
	dd._c = 3;
	dd._d = 4;

	cout << sizeof(aa) << endl; //8
	cout << sizeof(bb) << endl; //24
	cout << sizeof(cc) << endl; //24
	cout << sizeof(dd) << endl; //40 = 24+24-8-4+4 //虚继承共用一个父类A,所以-8，父类B,C用同一个占位地址-4。
}


/*
三大特性总结：
封装：
1、封装：二中方法（1、类将数据和函数捆绑，2、访问限制符限制）
2、作用：信息隐藏，只提供必要接口，防止外部干扰

继承：
1、方式：public（is-a） protected,private（has-a）
2、作用：通过子类继承父类实现代码复用。
分类：
单继承---只有一个直接父类
多继承---有多个直接父类
菱形继承---单继承和多继承的复合
缺陷：数据二义性，数据冗余
解决：虚继承
虚基表
1、存放到虚表的的偏移量
2、存放到父类的偏移量


多态：
分类：静态多态，动态多态
作用：一个接口实现多种功能，根据对象调用对应的实现函数
必要条件：
1、父，子类中必须有完全相同的虚函数。
2、必须是父类的指针或引用。
虚函数：
使用关键字virtual修饰的函数
虚表
存放虚函数的地址（函数指针数组）
父类有虚表时不创建虚表，有多大个父类时，每个父类都会形成多态，但只将自己的虚函数放在最先继承的父类中
最好为虚函数：析构函数
不可为虚函数：构造，静态，友元，内联。
纯虚函数：在虚函数后写 = 0；函数地址初始为0，告诉编译器不为该函数编址从而使类不可实例化出对象。
含有纯虚函数的类称为抽象类，若继承方式为public的类称为接口类。

如何定义一个不可被继承的类？
解：将类的构造函数定义成私有的。
1、类的私有成员只能在类内可访问，子类不可见。
2、子类是合成的，调用子类的构造函数时会先调用父类的构造函数。





*/